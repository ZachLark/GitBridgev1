#!/usr/bin/env python3
"""
GitBridge Cursor File Format Specification
Task: P20P4S1 - Cursor File Format Specification

This module defines the standardized Markdown formats for GPT-4o output
that will be written to Cursor workspace files (.suggestion.md, .task.md, .log.md).

Author: GitBridge Development Team
Date: 2025-01-11
"""

import json
import logging
from typing import Dict, Any, Optional, List
from datetime import datetime, timezone
from dataclasses import dataclass
from enum import Enum

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class CursorFileType(str, Enum):
    """Valid Cursor file types for GPT-4o output."""
    SUGGESTION = "suggestion"
    TASK = "task"
    LOG = "log"


class ConfidenceLevel(str, Enum):
    """Confidence levels for GPT-4o recommendations."""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"


@dataclass
class CursorFileMetadata:
    """Metadata for Cursor file headers."""
    event_id: str
    source: str
    session_id: str
    timestamp: str
    confidence: ConfidenceLevel
    file_type: CursorFileType
    gpt_model: str
    protocol_version: str = "2.1"


class CursorFileFormatter:
    """
    Formatter for creating Cursor-compatible Markdown files from GPT-4o output.
    
    Supports three file types:
    - .suggestion.md: Recommended improvements or code edits
    - .task.md: Next actions, subtasks, or TODO items
    - .log.md: Debug insights, rationale, or analysis
    """
    
    def __init__(self):
        self.template_cache = {}
    
    def create_file_header(self, metadata: CursorFileMetadata) -> str:
        """
        Create standardized file header with metadata.
        
        Args:
            metadata: File metadata
            
        Returns:
            str: Formatted header
        """
        header_parts = [
            "---",
            f"# GitBridge AI Output - {metadata.file_type.value.title()}",
            "---",
            "",
            "## Metadata",
            f"- **Event ID**: `{metadata.event_id}`",
            f"- **Source**: {metadata.source}",
            f"- **Session ID**: `{metadata.session_id}`",
            f"- **Timestamp**: {metadata.timestamp}",
            f"- **Confidence**: {metadata.confidence.value}",
            f"- **File Type**: {metadata.file_type.value}",
            f"- **GPT Model**: {metadata.gpt_model}",
            f"- **Protocol**: MAS Lite v{metadata.protocol_version}",
            "",
            "---",
            ""
        ]
        return "\n".join(header_parts)
    
    def format_suggestion(self, content: str, metadata: CursorFileMetadata, 
                         context: Optional[str] = None) -> str:
        """
        Format GPT-4o output as a suggestion file.
        
        Args:
            content: GPT-4o response content
            metadata: File metadata
            context: Optional context about the suggestion
            
        Returns:
            str: Formatted .suggestion.md content
        """
        sections = [self.create_file_header(metadata)]
        
        if context:
            sections.extend([
                "## Context",
                context,
                ""
            ])
        
        sections.extend([
            "## Suggestion",
            content,
            ""
        ])
        
        # Add confidence-based guidance
        if metadata.confidence == ConfidenceLevel.LOW:
            sections.append("> **Note**: This is a low-confidence suggestion. Please review carefully before implementing.")
        elif metadata.confidence == ConfidenceLevel.HIGH:
            sections.append("> **Note**: This is a high-confidence suggestion. Consider implementing with standard testing.")
        
        sections.extend([
            "---",
            f"*Generated by GitBridge AI at {metadata.timestamp}*"
        ])
        
        return "\n".join(sections)
    
    def format_task(self, content: str, metadata: CursorFileMetadata,
                   priority: Optional[str] = None, 
                   estimated_time: Optional[str] = None) -> str:
        """
        Format GPT-4o output as a task file.
        
        Args:
            content: GPT-4o response content
            metadata: File metadata
            priority: Task priority (low/medium/high)
            estimated_time: Estimated completion time
            
        Returns:
            str: Formatted .task.md content
        """
        sections = [self.create_file_header(metadata)]
        
        # Add task metadata
        task_meta = []
        if priority:
            task_meta.append(f"- **Priority**: {priority}")
        if estimated_time:
            task_meta.append(f"- **Estimated Time**: {estimated_time}")
        
        if task_meta:
            sections.extend([
                "## Task Metadata",
                *task_meta,
                ""
            ])
        
        sections.extend([
            "## Task Description",
            content,
            ""
        ])
        
        # Add task checklist template
        sections.extend([
            "## Checklist",
            "- [ ] Review task requirements",
            "- [ ] Implement solution",
            "- [ ] Test changes",
            "- [ ] Update documentation",
            "- [ ] Submit for review",
            ""
        ])
        
        sections.extend([
            "---",
            f"*Generated by GitBridge AI at {metadata.timestamp}*"
        ])
        
        return "\n".join(sections)
    
    def format_log(self, content: str, metadata: CursorFileMetadata,
                   log_level: str = "info") -> str:
        """
        Format GPT-4o output as a log file.
        
        Args:
            content: GPT-4o response content
            metadata: File metadata
            log_level: Log level (debug/info/warning/error)
            
        Returns:
            str: Formatted .log.md content
        """
        sections = [self.create_file_header(metadata)]
        
        sections.extend([
            f"## Log Entry ({log_level.upper()})",
            content,
            ""
        ])
        
        # Add analysis section if content suggests it
        if any(keyword in content.lower() for keyword in ["analysis", "insight", "finding", "observation"]):
            sections.extend([
                "## Key Insights",
                "> *Extracted from AI analysis above*",
                "",
                "- [Insight 1]",
                "- [Insight 2]",
                "- [Insight 3]",
                ""
            ])
        
        sections.extend([
            "---",
            f"*Generated by GitBridge AI at {metadata.timestamp}*"
        ])
        
        return "\n".join(sections)
    
    def determine_file_type_and_confidence(self, content: str, 
                                         requested_output: Optional[str] = None) -> tuple[CursorFileType, ConfidenceLevel]:
        """
        Determine the appropriate file type and confidence level based on content.
        
        Args:
            content: GPT-4o response content
            requested_output: Original requested output type
            
        Returns:
            tuple: (file_type, confidence_level)
        """
        content_lower = content.lower()
        
        # Determine file type
        if requested_output:
            if "comment" in requested_output or "review" in requested_output:
                file_type = CursorFileType.SUGGESTION
            elif "summary" in requested_output:
                file_type = CursorFileType.LOG
            elif "task" in requested_output or "action" in requested_output:
                file_type = CursorFileType.TASK
            else:
                file_type = CursorFileType.SUGGESTION
        else:
            # Auto-detect based on content
            if any(word in content_lower for word in ["suggest", "recommend", "improve", "fix", "change"]):
                file_type = CursorFileType.SUGGESTION
            elif any(word in content_lower for word in ["task", "todo", "action", "next", "implement"]):
                file_type = CursorFileType.TASK
            else:
                file_type = CursorFileType.LOG
        
        # Determine confidence level
        if any(word in content_lower for word in ["definitely", "certainly", "should", "must", "highly recommend"]):
            confidence = ConfidenceLevel.HIGH
        elif any(word in content_lower for word in ["maybe", "consider", "might", "possibly", "could"]):
            confidence = ConfidenceLevel.LOW
        else:
            confidence = ConfidenceLevel.MEDIUM
        
        return file_type, confidence
    
    def format_content(self, content: str, metadata: CursorFileMetadata,
                      context: Optional[str] = None,
                      requested_output: Optional[str] = None) -> str:
        """
        Main method to format GPT-4o content into appropriate Cursor file format.
        
        Args:
            content: GPT-4o response content
            metadata: File metadata
            context: Optional context
            requested_output: Original requested output type
            
        Returns:
            str: Formatted content for Cursor file
        """
        # Auto-determine file type and confidence if not specified
        if not metadata.file_type or not metadata.confidence:
            file_type, confidence = self.determine_file_type_and_confidence(content, requested_output)
            metadata.file_type = metadata.file_type or file_type
            metadata.confidence = metadata.confidence or confidence
        
        # Format based on file type
        if metadata.file_type == CursorFileType.SUGGESTION:
            return self.format_suggestion(content, metadata, context)
        elif metadata.file_type == CursorFileType.TASK:
            return self.format_task(content, metadata)
        elif metadata.file_type == CursorFileType.LOG:
            return self.format_log(content, metadata)
        else:
            # Default to suggestion
            return self.format_suggestion(content, metadata, context)


def create_sample_files():
    """Create sample Cursor files for testing and documentation."""
    formatter = CursorFileFormatter()
    
    # Sample metadata
    metadata = CursorFileMetadata(
        event_id="gh_pr_12345_20250111_001",
        source="github",
        session_id="webhook_1234567890",
        timestamp=datetime.now(timezone.utc).isoformat(),
        confidence=ConfidenceLevel.MEDIUM,
        file_type=CursorFileType.SUGGESTION,
        gpt_model="gpt-4o"
    )
    
    # Sample suggestion
    suggestion_content = """Consider adding input validation to the JWT token handler. The current implementation doesn't validate token expiration or signature properly.

**Recommended changes:**
1. Add token expiration check
2. Implement proper signature verification
3. Add error handling for malformed tokens

This will improve security and prevent potential authentication bypasses."""
    
    suggestion_file = formatter.format_suggestion(suggestion_content, metadata)
    
    # Sample task
    task_metadata = CursorFileMetadata(
        event_id="gh_pr_12345_20250111_001",
        source="github",
        session_id="webhook_1234567890",
        timestamp=datetime.now(timezone.utc).isoformat(),
        confidence=ConfidenceLevel.HIGH,
        file_type=CursorFileType.TASK,
        gpt_model="gpt-4o"
    )
    
    task_content = """Implement comprehensive test coverage for the new authentication module.

**Required actions:**
1. Create unit tests for JWT token validation
2. Add integration tests for login/logout flows
3. Test error handling scenarios
4. Verify security edge cases"""
    
    task_file = formatter.format_task(task_content, task_metadata, priority="high", estimated_time="2-3 hours")
    
    # Sample log
    log_metadata = CursorFileMetadata(
        event_id="gh_pr_12345_20250111_001",
        source="github",
        session_id="webhook_1234567890",
        timestamp=datetime.now(timezone.utc).isoformat(),
        confidence=ConfidenceLevel.MEDIUM,
        file_type=CursorFileType.LOG,
        gpt_model="gpt-4o"
    )
    
    log_content = """Analysis of Pull Request #123: User Authentication Feature

**Summary:**
- Overall code quality: Good
- Security considerations: Needs improvement
- Test coverage: Adequate but could be expanded
- Documentation: Well documented

**Key findings:**
1. JWT implementation follows best practices
2. Missing input validation in token handler
3. Test coverage is 85% - good baseline
4. Documentation is comprehensive and clear"""
    
    log_file = formatter.format_log(log_content, log_metadata, log_level="info")
    
    return {
        "suggestion": suggestion_file,
        "task": task_file,
        "log": log_file
    }


def main():
    """Main function for testing and demonstration."""
    print("📝 GitBridge Cursor File Format Specification")
    print("Task: P20P4S1 - Cursor File Format Specification")
    print("=" * 60)
    
    # Create sample files
    samples = create_sample_files()
    
    # Display samples
    for file_type, content in samples.items():
        print(f"\n--- {file_type.upper()} FILE EXAMPLE ---")
        print(content)
        print("\n" + "="*60)
    
    print("✅ Cursor file format specification complete!")
    print("📁 Sample files ready for testing")


if __name__ == "__main__":
    main() 